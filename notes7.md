- in Multiprogramming environment we have multiple process in the main memory to keep the CPU utilization high and make computer responsive
  to the users

- because of this we have to manage the main memory for all different process 

## logical address vs physical address
- logical address(Virtual Address):
1) generated by the CPU for the instruction and data for the user by a process
2) Accessible by the user process but does not physically exist
3) Represent the full range of addressable memory (0 to max)
4) Also known as Virtual address Space

- Physical Address:
1) Actual location in physical main memory(RAM)
2) Not directly accessible by the user process
3) Computed by the MMU( Memory Management Unit)
4) Represent a subset of the full memory range typically (R+0) to (R+max)
where R is the base value that is given with the offset in the logical address
to see the range 

- Memory management unit perform the mapping of the logical address of the process generated by the CPU to physical address in main memory

- while the user's operate in logical address the actual execution require 
physical address


- how memory mapping and Protection?
a. The OS provides the concept of Virtual Address Space (VAS) to processes.

b. To separate memory spaces, the OS needs to determine the range of legal addresses a process can access and ensure the process can only access those addresses.

c. The relocation register contains the base physical address, and the limit register contains the range of valid logical addresses for the process.

d. Each logical address generated by the process must be less than the value in the limit register.

e. The Memory Management Unit (MMU) dynamically maps logical addresses to physical addresses by adding the value in the relocation register.

f. During a context switch, the CPU scheduler loads the relocation and limit registers with the correct values for the next process.

g. Any attempt by a user process to access operating system memory or another process's memory results in a trap to the OS, which treats it as a fatal error.

By using relocation and limit registers, and having the MMU check every logical address against these registers, the OS can provide memory isolation and protection for itself, as well as between different user processes.

## Allocation Method in Physical Memory
- Contiguous Allocation
- Non-Contiguous Allocation

## Contiguous Allocation
- in this process, each process is contained in a single contiguous memory block
- Fixed Partitioning:
- the main memory is divided into partition of equal of different sizes
  with same size of the main memory

- Limitation:
- Internal Fragmentation: If the size of a process is smaller than the partition size, the remaining unused memory within the partition is wasted, leading to internal fragmentation.

- External Fragmentation: While there may be total unused space across various partitions, it may not be contiguous, preventing it from being used to load larger processes.

- Limitation on Process Size: Processes larger than the maximum partition size cannot be loaded into memory, imposing a limit on process size.

- Low Degree of Multiprogramming: The degree of multiprogramming is fixed and limited, as partition sizes cannot be varied according to process sizes.

- Dynamic Partitioning
- in this technique , we partition size is not declared initially . it is 
  declared at the time of process loading


- Advantage:
- NO internal fragmentation
- No limit size of process
- Better degree of multiprogramming

- Disadvantage:
- External Fragmentation


- Defragmentation/Compaction:
- Dynamic partitioning can lead to external fragmentation, where there are non-contiguous free memory blocks that can't be allocated for larger processes.

- Defragmentation or compaction is a technique that aims to resolve this issue by:

- Making all free memory partitions contiguous
- Moving all loaded partitions together
- This merges the free memory into a larger single block that can accommodate larger processes.

- However, compaction introduces overhead due to the need to move and  reorganize memory contents during the defragmentation process, impacting system efficiency.

## how free space is stored in os
- Free Holes in the memory are represented by a free list(Linked list Data structure (Doubly linked list))

## how to satisfy a request of n size from a list of free holes?
a. The algorithms operate on a linked list of free memory holes/partitions.

b. First Fit: Allocates the first hole that is big enough for the process. Simple and fast.

c. Next Fit: Like First Fit, but starts searching from the last allocated hole. Fast.

d. Best Fit: Allocates the smallest hole that can accommodate the process. Minimizes internal fragmentation but may cause external fragmentation by creating many small holes. Slower due to searching the entire free list.

e. Worst Fit: Allocates the largest available hole for the process. Leaves larger holes for potential future processes. Slow due to searching the entire free list.

The choice of algorithm involves trade-offs between memory utilization (minimizing internal/external fragmentation), speed of allocation, and maintaining larger holes for future processes. First Fit and Next Fit are simple and fast, while Best Fit minimizes internal fragmentation but may increase external fragmentation over time. Worst Fit aims to leave larger holes for potential future processes.


## Main disadvantage of Dynamic partitioning is External Fragmentation
- Can be removed by compaction but with overhead
- We need more flexible/efficient/optimal mechanism to lead

## Idea behind the paging
- The key idea behind paging is to divide the physical memory into equal-sized blocks (pages) and allow processes to be allocated these pages, even if they are not contiguous in physical memory. This allows better memory utilization and overcomes the external fragmentation issue faced by contiguous memory allocation schemes.


- Paging
a. Paging allows the physical address space of a process to be non-contiguous.

b. It avoids external fragmentation and the need for compaction.

c. Physical memory is divided into fixed-sized blocks called frames, and logical memory is divided into blocks of the same size called pages.

d. The page size is determined by the processor architecture and can be uniform or allow multiple page sizes.

e. A page table stores the mapping of which page is mapped to which frame in physical memory.

f. Every logical address generated by the CPU is divided into a page number (p) and a page offset (d). The page number is used as an index into the page table to find the base address of the corresponding frame.

g. The page table is stored in main memory during process creation, and its base address is stored in the process control block (PCB).

h. A page table base register (PTBR) points to the current page table, allowing efficient context switching by changing just this one register.

f. Paging avoids external fragmentation because non-contiguous allocation of a process's pages is allowed in random free frames of physical memory.

g. Paging can be slow because there are multiple memory references required to access the desired location in physical memory, involving lookups in the page table.

- Translation Look Aside buffer(TLB)
- TLB is a hardware cache that stores recently used virtual-to-physical address mappings (page to frame mappings).
On a memory reference, TLB is checked first before accessing the page table.
- TLB hit: mapping found in TLB, physical address retrieved quickly.
- TLB miss: mapping not found, page table accessed, new mapping loaded into TLB.
- TLB entries contain Address Space Identifier (ASID) for process identification.
- ASID allows TLB to hold entries for multiple processes simultaneously.
- ASID provides address space protection by matching with the current process.


## Segmentation
- Segmentation is a technique that supports the user's view of logical memory.

- In segmentation, the logical address space is a collection of variable-sized segments based on the user's perspective.

- Each segment is defined by a segment number and an offset: <segment-number, offset>.

- Processes are divided into variable segments aligning with the user's view of the process structure.

- Paging is more oriented towards the operating system's view of memory, dividing processes into fixed-size pages, potentially separating related functions across pages.

- The OS does not consider the user's view of the process when paging, which can decrease efficiency by splitting related functions across different pages that may not be loaded together.

- Segmentation is better suited to the user's perspective by grouping related functions into the same segment, improving efficiency and aligning with the logical structure of the process from the user's point of view.